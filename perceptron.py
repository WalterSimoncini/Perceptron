import time 
import random

line_separator = "\n------------------------------------------------------------------\n"

learning_constant = 0.1

# Targets and inputs for the OR function
# targets = [0, 1, 1, 1] 
# The values of each input array correspond to input node 1, input node 2 and the bias input which is always one
# inputs = [[0, 0, 1], [0, 1, 1], [1, 0, 1], [1, 1, 1]]

# Targets and inputs for the AND function
targets = [0, 0, 0, 1]
inputs = [[0, 0, 1], [0, 1, 1], [1, 0, 1], [1, 1, 1]]

# Initialize the weights with random values
weights = [random.uniform(-1.0, 1.0), random.uniform(-1.0, 1.0), random.uniform(-1.0, 1.0)]
sum_error = 1000

# This function implements the behavior of the sign function so if the input value is higher
# than 0 it will return 1 and 0 otherwise.
def activation_function (value):
        if value > 0:
            return 1
        else:
            return 0

print "Random weights: " + str(weights) + line_separator

epoch = 1
while sum_error > 0:
    sum_error = 0.0

    for i in range(0, len(targets)):
        t = targets[i]

        # Calculate the sum of the network inputs
        output = inputs[i][0] * weights[0] + inputs[i][1] * weights[1] + inputs[i][2] * weights[2]

        # Calculate the output of the network
        activation = activation_function(output)

        # Calculate the error generated by the network, calculated as the difference between
        # the target and the output generated by the network
        error = t - activation

        sum_error += abs(error)

        # Calculate the deltas added to the weights of the input nodes
        for j in range(0, len(weights)):
            delta = learning_constant * error * inputs[i][j]
            weights[j] += delta

        print "Target: " + str(t) + " - Ouput: " + str(output) + " -> Activation: " + str(activation) + " - Weights: " + str(weights)
    
    print("\nEpoch " + str(epoch) + " with error sum: " + str(sum_error) + line_separator)

    # Pause 1 second between each epoch to let the user see the perceptron's progress
    time.sleep(1)
    epoch += 1