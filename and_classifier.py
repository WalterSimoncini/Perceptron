import time 
import random

learning_rate = 0.1
line_separator = "\n------------------------------------------------------------------\n"

# Targets and inputs for the AND function. The inputs are encoded 
# as a triplet in the format [bias_node_input, input_1, input_2]
targets = [0, 0, 0, 1]
inputs = [[1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1]]

# Initialize the weights with the values from the slides
weights = [-0.3, 0.1, 0.3]
sum_error = 1000

def step_function (value, t):
    if value >= t:
        return 1
    else:
        return 0

print("\nWeights: " + str(weights) + "\n" + line_separator)

while sum_error > 0:
    sum_error = 0.0

    for i in range(0, len(targets)):
        t = targets[i]

        # Calculate the weighted sum of the network inputs
        output = inputs[i][0] * weights[0] + inputs[i][1] * weights[1] + inputs[i][2] * weights[2]

        # Calculate the activation of the ouput node
        activation = step_function(output, 0)

        # Calculate the error generated by the network, computed as the difference between
        # the target and the output generated by the network
        error = t - activation
        sum_error += abs(error)

        # Build the ouput calculation string
        log = str(inputs[i][0]) + " x " + str(weights[0]) + " + "
        log += str(inputs[i][1]) + " x " + str(weights[1]) + " + "
        log += str(inputs[i][2]) + " x " + str(weights[2]) + " = "
        log += str(output) + " -> output: " + str(activation) + " -> " 
        log += ("correct" if error == 0 else "not correct")

        print(log)

        # Calculate the deltas added to the weights of the input nodes
        if error != 0:
            deltas = []
            for j in range(0, len(weights)):
                delta = learning_rate * error * inputs[i][j]
                if delta == 0: delta = 0.0 # Make sure not to generate output like -0.0
                deltas.append(delta)

                delta_log = "\t dw" + str(j) + " = " 
                delta_log += str(learning_rate) + " x (" + str(t) + " - " + str(activation) + ") x "
                delta_log += str(inputs[i][j]) + " = " + str(delta)
                
                print(delta_log)
                
            print("\nUpdate the weights:")

            for v in range(0, len(deltas)):
                if abs(deltas[v]) == 0: continue
                
                # Round off the weights in order to avoid floating point arithmetic errors
                tmp_weight = round(weights[v] + deltas[v], 10)
                
                weight_log = "\t W" + str(v) + " = "
                weight_log += str(weights[v]) + " + " + str(deltas[v]) + " = " + str(tmp_weight)

                print(weight_log)

                weights[v] = tmp_weight

        if error: break
    
    print(line_separator)